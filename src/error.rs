//! Errors & utilities to manage them.

use std::{fmt::Display, sync::Arc};

use async_trait::async_trait;
use k8s_openapi::api::core::v1::ObjectReference;
use kube::runtime::finalizer::Error as FinalizerError;
use thiserror::Error;

use crate::{
    event_manager::{EventManager, EventType},
    with_source::ValueWithSource,
    Context, EventCore,
};

macro_rules! maybe {
    ($value:expr) => {
        $value
            .clone()
            .map_or("".to_string(), |value| format!(": {value:?}"))
    };
}

/// The error type of this crate.
///
/// Any error that needs to propagate up needs to be of this type, and any error generated by another crate that isn't handled needs to be wrapped in this type.
#[derive(Error, Debug, Clone)]
pub enum Error {
    /// Wrapped errors for a failed reconcile action.
    #[error("Finalizer error: {0}")]
    Finalizer(#[source] Arc<FinalizerError<Error>>),

    /// A misconfiguration of a Kubernetes resource. This is only for problems that require a change to a resource to resolve, not for temporary failures that might resolve by themselves.
    #[error("Invalid resource: {0}")]
    InvalidResource(String),

    /// The MQTT broker responded in an unexpected manner.
    #[error("MQTT error: {0}{err}", err = maybe!(.1))]
    Mqtt(
        String,
        #[source] Option<Arc<dyn std::error::Error + Send + Sync>>,
    ),

    /// The Zigbee2MQTT application responded in an unexpected manner.
    #[error("Zigbee2MQTT error: {0}")]
    Zigbee2Mqtt(String),

    /// Something in the process of reading and processing messages for a subscription failed.
    #[error("Subscription error on topic {topic}: {message}{err}", err = maybe!(.source))]
    Subscription {
        /// The topic of the subscription that generated this error.
        topic: String,
        /// A human-readable message describing the issue.
        message: String,
        /// The underlying error that caused this issue, if any.
        #[source]
        source: Option<Arc<dyn std::error::Error + Send + Sync>>,
    },

    /// A manager has been shut down and should no longer be used.
    #[error("Manager has been shut down{err}", err = maybe!(.0))]
    ManagerShutDown(Option<Box<Error>>),

    /// Some invariant failed. This probably indicates a bug, and it will cause the affected subsystem to be restarted to get back to a known state.
    #[error("Invariant failed: {0}{err}", err = maybe!(.1))]
    InvariantFailed(String, Option<Box<Error>>),

    /// Something prevented the requested action from completing successfully. This is the catch-all for all errors that don't fit any of the more specific types.
    #[error("Action failed: {0}")]
    ActionFailed(
        String,
        #[source] Option<Arc<dyn std::error::Error + Send + Sync>>,
    ),
}
impl From<ErrorWithMeta> for Error {
    fn from(value: ErrorWithMeta) -> Self {
        value.error().to_owned()
    }
}

/// An [`enum@Error`] with some additional metadata needed to publish a corresponding [`k8s_openapi::api::events::v1::Event`].
#[allow(clippy::module_name_repetitions)]
#[derive(Debug)]
pub struct ErrorWithMeta {
    error: Error,
    source: Option<String>,
    published: bool,
}
impl Error {
    /// Add source information to the error.
    #[must_use]
    pub fn caused_by<T>(self, value: &ValueWithSource<T>) -> ErrorWithMeta {
        ErrorWithMeta {
            error: self,
            source: value.source().cloned(),
            published: false,
        }
    }

    /// Convert without source information.
    #[must_use]
    pub fn unknown_cause(self) -> ErrorWithMeta {
        ErrorWithMeta {
            error: self,
            source: None,
            published: false,
        }
    }
}
impl ErrorWithMeta {
    /// Get error.
    #[must_use]
    pub fn error(&self) -> &Error {
        &self.error
    }

    /// Get source.
    #[must_use]
    pub fn source(&self) -> Option<&String> {
        self.source.as_ref()
    }

    /// Mark as already published, which will prevent it from being published again when [`ErrorWithMeta::publish`] is called..
    #[must_use]
    pub fn mark_published(mut self) -> ErrorWithMeta {
        self.published = true;
        self
    }
}
impl From<Error> for ErrorWithMeta {
    fn from(value: Error) -> Self {
        value.unknown_cause()
    }
}
impl Display for ErrorWithMeta {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        self.error.fmt(f)
    }
}

/// Trait to finalize the contained error in a [`Result<_, ErrorWithMeta>`] by publishing it if needed and then unwrapping it.
#[allow(clippy::module_name_repetitions)]
#[async_trait]
pub trait ErrorWithMetaFinalizer<V> {
    /// Unwrap the underlying error (if any), publishing it as an event if needed.
    #[must_use]
    async fn publish_unwrap_error(
        self,
        ctx: &Arc<Context>,
        regarding: ObjectReference,
    ) -> Result<V, Error>;
}
#[async_trait]
impl<V> ErrorWithMetaFinalizer<V> for Result<V, ErrorWithMeta>
where
    V: Send,
{
    async fn publish_unwrap_error(
        self,
        ctx: &Arc<Context>,
        regarding: ObjectReference,
    ) -> Result<V, Error> {
        match self {
            Ok(value) => Ok(value),
            Err(withmeta) => {
                if !withmeta.published {
                    let eventmanager = EventManager::new(ctx.client.clone(), regarding);
                    eventmanager
                        .publish_nolog(EventCore {
                            action: "Reconciling".to_string(),
                            note: Some(withmeta.error.to_string()),
                            reason: "Created".to_string(),
                            type_: EventType::Warning,
                            field_path: withmeta.source,
                        })
                        .await;
                }

                Err(withmeta.error)
            }
        }
    }
}
