//! Errors & utilities to manage them.

use std::sync::Arc;

use async_trait::async_trait;
use kube::runtime::finalizer::Error as FinalizerError;
use thiserror::Error;

use crate::event_manager::{EventCore, EventManager, EventType};

macro_rules! maybe {
    ($value:expr) => {
        $value
            .clone()
            .map_or("".to_string(), |value| format!(": {:?}", value))
    };
}

/// The error type of this crate.
///
/// Any error that needs to propagate up needs to be of this type, and any error generated by another crate that isn't handled needs to be wrapped in this type.
#[derive(Error, Debug, Clone)]
pub enum Error {
    /// Wrapped errors for a failed reconcile action.
    #[error("Finalizer error: {0}")]
    FinalizerError(#[source] Arc<Box<FinalizerError<Error>>>),

    /// A misconfiguration of a Kubernetes resource. This is only for problems that require a change to a resource to resolve, not for temporary failures that might resolve by themselves.
    #[error("Invalid resource: {0}")]
    InvalidResource(String),

    /// The MQTT broker responded in an unexpected manner.
    #[error("MQTT error: {0}{err}", err = maybe!(.1))]
    MQTTError(
        String,
        #[source] Option<Arc<Box<dyn std::error::Error + Send + Sync>>>,
    ),

    /// The Zigbee2MQTT application responded in an unexpected manner.
    #[error("Zigbee2MQTT error: {0}")]
    Zigbee2MQTTError(String),

    /// Something in the process of reading and processing messages for a subscription failed.
    #[error("Subscription error on topic {topic}: {message}{err}", err = maybe!(.source))]
    SubscriptionError {
        /// The topic of the subscription that generated this error.
        topic: String,
        /// A human-readable message describing the issue.
        message: String,
        /// The underlying error that caused this issue, if any.
        #[source]
        source: Option<Arc<Box<dyn std::error::Error + Send + Sync>>>,
    },

    /// A manager has been shut down and should no longer be used.
    #[error("Manager has been shut down{err}", err = maybe!(.0))]
    ManagerShutDown(Option<Box<Error>>),

    /// Some invariant failed. This probably indicates a bug, and it will cause the affected subsystem to be restarted to get back to a known state.
    #[error("Invariant failed: {0}{err}", err = maybe!(.1))]
    InvariantFailed(String, Option<Box<Error>>),

    /// Something prevented the requested action from completing successfully. This is the catch-all for all errors that don't fit any of the more specific types.
    #[error("Action failed: {0}")]
    ActionFailed(
        String,
        #[source] Option<Arc<Box<dyn std::error::Error + Send + Sync>>>,
    ),
}

/// An [`enum@Error`] for which an [`k8s_openapi::api::events::v1::Event`] has already been published.
///
/// Created with [`EmittableResult`].
#[allow(clippy::module_name_repetitions)]
pub struct EmittedError(pub Error);

/// Helper to emit an [`enum@Error`] contained inside a [`Result`], converting it to an [`EmittedError`] in the process.
#[async_trait]
pub trait EmittableResult<V> {
    /// Publish error.
    async fn emit_event<F>(self, manager: &EventManager) -> Result<V, EmittedError>;

    /// Shorthand version of [`EmittableResult::emit_event_map`] which sets only [`EventCore::field_path`].
    async fn emit_event_with_path(
        self,
        manager: &EventManager,
        field_path: &str,
    ) -> Result<V, EmittedError>;

    /// Publish error, allowing closure to alter [`EventCore`] beforehand.
    async fn emit_event_map<F>(self, manager: &EventManager, f: F) -> Result<V, EmittedError>
    where
        F: FnOnce(&mut EventCore) + Send;

    /// Mark error as published without actually publishing anything. This should only be used in cases where one or more events have already been published for the error manually.
    fn fake_emit_event(self) -> Result<V, EmittedError>;
}
#[async_trait]
impl<V> EmittableResult<V> for Result<V, Error>
where
    V: Send,
{
    async fn emit_event<F>(self, manager: &EventManager) -> Result<V, EmittedError> {
        self.emit_event_map(manager, |_| {}).await
    }

    async fn emit_event_with_path(
        self,
        manager: &EventManager,
        field_path: &str,
    ) -> Result<V, EmittedError> {
        self.emit_event_map(manager, |event| {
            event.field_path = Some(field_path.to_string());
        })
        .await
    }

    async fn emit_event_map<F>(self, manager: &EventManager, f: F) -> Result<V, EmittedError>
    where
        F: FnOnce(&mut EventCore) + Send,
    {
        if let Err(ref error) = self {
            let mut event = EventCore {
                action: "Reconciling".to_string(),
                note: Some(error.to_string()),
                reason: "Created".to_string(),
                type_: EventType::Warning,
                ..EventCore::default()
            };
            f(&mut event);
            manager.publish_nolog(event).await;
        }
        self.map_err(EmittedError)
    }

    fn fake_emit_event(self) -> Result<V, EmittedError> {
        self.map_err(EmittedError)
    }
}
